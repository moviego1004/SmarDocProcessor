@page "/"
@using System.IO
@using Windows.Media.Ocr
@using SmartDocProcessor.Services
@using Microsoft.Win32 
@using System.Text.Json
@using System.Windows 
@using System.Windows.Media.Imaging
@using System.Timers 
@using System.Collections.Generic
@inject IOcrService OcrService
@inject IPdfService PdfService
@inject IJSRuntime JS
@inject HistoryService HistoryService
@implements IDisposable

<div class="main-layout" @onmousemove="OnGlobalMouseMove" @onmouseup="OnGlobalMouseUp" @onclick="CloseMenus" tabindex="0">
    
    <div class="ribbon-bar">
        <div class="app-brand" style="font-weight:bold; margin-right:10px;">SmartPDF</div>
        
        <div class="tool-section">
            <button class="icon-btn" @onclick="OpenFileWithDialog">ğŸ“‚ <span class="btn-label">ì—´ê¸°</span></button>
            <button class="icon-btn" @onclick="SavePdf" disabled="@(activeDoc == null)">ğŸ’¾ <span class="btn-label">ì €ì¥</span></button>
            <button class="icon-btn" @onclick="SavePdfAs" disabled="@(activeDoc == null)">ğŸ’¾ <span class="btn-label">ë‹¤ë¥¸ ì´ë¦„</span></button>
        </div>
        <div class="divider"></div>
        
        <div class="tool-section">
            <button class="icon-only-btn" @onclick="ZoomOut" disabled="@(activeDoc == null || isRendering)">â–</button>
            <span class="zoom-info" @onclick="ResetZoom" style="cursor:pointer; min-width:40px; text-align:center;">@((activeDoc?.Scale * 100 ?? 100).ToString("0"))%</span>
            <button class="icon-only-btn" @onclick="ZoomIn" disabled="@(activeDoc == null || isRendering)">â•</button>
            <button class="icon-btn" @onclick="FitToWidth" disabled="@(activeDoc == null)">â†”</button>
            <button class="icon-btn" @onclick="FitToPage" disabled="@(activeDoc == null)">â†•</button>
        </div>
        <div class="divider"></div>

        <div class="tool-section responsive-tool-section">
            <button class="icon-btn @(showSearchBar ? "active" : "")" @onclick="ToggleSearchBar" disabled="@(activeDoc == null)">ğŸ” <span class="btn-label">ê²€ìƒ‰</span></button>
            <button class="icon-btn" @onclick="GenerateSearchablePdf" disabled="@(activeDoc == null || isOcrProcessing)" title="ì „ì²´ í˜ì´ì§€ë¥¼ ìŠ¤ìº”í•˜ì—¬ ê²€ìƒ‰ ê°€ëŠ¥í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.">ğŸ‘ï¸ <span class="btn-label">OCR</span></button>
            
            <div class="divider"></div>
            
            <button class="icon-btn @(activeMode == "INFO" ? "active" : "")" @onclick='() => SetMode("INFO")' disabled="@(activeDoc == null)" title="í…ìŠ¤íŠ¸ ì„ íƒ ë° íŒì—… ë©”ë‰´">ğŸ‘† <span class="btn-label">ì„ íƒ</span></button>
            <button class="icon-btn @(activeMode == "SNAPSHOT" ? "active" : "")" @onclick='() => SetMode("SNAPSHOT")' disabled="@(activeDoc == null)">ğŸ“· <span class="btn-label">ìº¡ì²˜</span></button>
            <button class="icon-btn @(activeMode == "TEXT" ? "active" : "")" @onclick='() => SetMode("TEXT")' disabled="@(activeDoc == null)">T <span class="btn-label">í…ìŠ¤íŠ¸</span></button>
            <button class="icon-btn @(activeMode == "HIGHLIGHT" ? "active" : "")" @onclick='() => SetMode("HIGHLIGHT")' disabled="@(activeDoc == null)">ğŸ–ï¸ <span class="btn-label">í˜•ê´‘íœ</span></button>
        </div>
        
        <div class="tool-section responsive-hide" style="margin-left:auto; margin-right:10px;">
            <div class="divider"></div>
            <button class="icon-btn" @onclick="DeleteSelected" disabled="@(activeDoc?.SelectedAnnotation == null)">âŒ <span class="btn-label">ì‚­ì œ</span></button>
            <button class="icon-btn" @onclick="Undo" disabled="@(activeDoc?.UndoStack.Count == 0)">â†©ï¸ <span class="btn-label">ì·¨ì†Œ</span></button>
            <div class="divider"></div>
            <div class="property-panel">
                <input type="color" class="color-picker" value="@currentInputColor" @onchange="OnColorChanged" />
                <select class="size-picker" value="@currentInputFontSize" @onchange="OnSizeChanged">
                    <option value="12">12</option><option value="16">16</option><option value="20">20</option><option value="24">24</option><option value="36">36</option>
                </select>
                @if (activeDoc?.SelectedAnnotation != null && activeDoc.SelectedAnnotation.Type == "TEXT") {
                    <button class="apply-btn" @onclick="ApplyStyles">ì ìš©</button>
                }
            </div>
        </div>
        
        <button class="more-btn" @onclick="ToggleMoreMenu" @onclick:stopPropagation="true" style="margin-left:auto;">â‹®</button>
    </div>

    @if (showMoreMenu) {
        <div class="overflow-menu" @onclick:stopPropagation="true" style="position: fixed; top: 50px; right: 10px; z-index: 2000;">
            <div class="overflow-section-label">ë„êµ¬</div>
            <div class="overflow-grid">
                <button class="icon-btn @(showSearchBar ? "active" : "")" @onclick='() => { ToggleSearchBar(); CloseMenus(); }' disabled="@(activeDoc == null)">ğŸ” ê²€ìƒ‰</button>
                <button class="icon-btn" @onclick='() => { GenerateSearchablePdf(); CloseMenus(); }' disabled="@(activeDoc == null || isOcrProcessing)">ğŸ‘ï¸ OCR</button>
                <button class="icon-btn @(activeMode == "INFO" ? "active" : "")" @onclick='() => { SetMode("INFO"); CloseMenus(); }' disabled="@(activeDoc == null)">ğŸ‘† ì„ íƒ</button>
                <button class="icon-btn @(activeMode == "SNAPSHOT" ? "active" : "")" @onclick='() => { SetMode("SNAPSHOT"); CloseMenus(); }' disabled="@(activeDoc == null)">ğŸ“· ìº¡ì²˜</button>
                <button class="icon-btn @(activeMode == "TEXT" ? "active" : "")" @onclick='() => { SetMode("TEXT"); CloseMenus(); }' disabled="@(activeDoc == null)">T í…ìŠ¤íŠ¸</button>
                <button class="icon-btn @(activeMode == "HIGHLIGHT" ? "active" : "")" @onclick='() => { SetMode("HIGHLIGHT"); CloseMenus(); }' disabled="@(activeDoc == null)">ğŸ–ï¸ í˜•ê´‘íœ</button>
            </div>
            
            <hr style="margin:5px 0; border:0; border-top:1px solid #eee;">
            
            <div class="overflow-section-label">í¸ì§‘</div>
            <div style="display:flex; gap:5px;">
                <button class="icon-btn" @onclick="DeleteSelected" disabled="@(activeDoc?.SelectedAnnotation == null)">âŒ ì‚­ì œ</button>
                <button class="icon-btn" @onclick="Undo" disabled="@(activeDoc?.UndoStack.Count == 0)">â†©ï¸ ì·¨ì†Œ</button>
            </div>
            
            <hr style="margin:5px 0; border:0; border-top:1px solid #eee;">
            
            <div class="overflow-section-label">ì†ì„±</div>
            <div style="display:flex; align-items:center;">
                <input type="color" class="color-picker" value="@currentInputColor" @onchange="OnColorChanged" />
                <select class="size-picker" value="@currentInputFontSize" @onchange="OnSizeChanged">
                    <option value="12">12</option><option value="16">16</option><option value="20">20</option><option value="24">24</option><option value="36">36</option>
                </select>
            </div>
            @if (activeDoc?.SelectedAnnotation != null && activeDoc.SelectedAnnotation.Type == "TEXT") {
                <button class="btn btn-sm btn-primary w-100 mt-2" @onclick="ApplyStyles">ìŠ¤íƒ€ì¼ ì ìš©</button>
            }
        </div>
    }

    <div class="tab-bar">
        @foreach (var doc in docs) {
            <div class="doc-tab @(activeDoc == doc ? "active" : "")" @onclick="() => SwitchTab(doc)">
                <span class="tab-title">@doc.FileName</span>
                <span class="close-tab" @onclick:stopPropagation="true" @onclick="() => CloseTab(doc)">âœ•</span>
            </div>
        }
    </div>

    <div class="workspace" @onclick="CloseMenus">
        <div class="sidebar" style="display: @(isSidebarOpen ? "flex" : "none"); width: @(sidebarWidth)px;">
            <div class="sidebar-tabs">
                <div class="tab-item @(activeTab == "PROP" ? "active" : "")" @onclick='() => activeTab = "PROP"'>ì†ì„±</div>
                <div class="tab-item @(activeTab == "PAGES" ? "active" : "")" @onclick='() => SwitchToPagesTab()'>í˜ì´ì§€</div>
            </div>
            @if (activeTab == "PROP") {
                <div class="sidebar-content">
                    @if (activeDoc == null) { <div class="text-center text-muted mt-5 small">íŒŒì¼ì„ ì—´ì–´ì£¼ì„¸ìš”.</div> } 
                    else { 
                        <p><strong>íŒŒì¼:</strong> @activeDoc.FileName</p>
                        <p><strong>í˜ì´ì§€:</strong> @activeDoc.TotalPages</p>
                        <hr />
                        <div class="alert alert-light small border">
                            <strong>ëª¨ë“œ ì•ˆë‚´:</strong><br/>
                            ğŸ‘† <strong>ì„ íƒ(ì½ê¸°):</strong> í…ìŠ¤íŠ¸ ì„ íƒ, íŒì—… ë©”ë‰´<br/>
                            ğŸ–ï¸ <strong>í˜•ê´‘íœ/ìº¡ì²˜:</strong> ë“œë˜ê·¸í•˜ì—¬ ë°•ìŠ¤ ê·¸ë¦¬ê¸°<br/>
                        </div>
                    }
                </div>
            } else if (activeTab == "PAGES") {
                <div id="sidebar-thumbnails" class="sidebar-content thumbnails-container">
                    <div class="mb-2 d-flex gap-2">
                        <button class="btn btn-sm btn-outline-primary w-100" @onclick="() => AddBlankPage()" disabled="@(activeDoc == null)">+ ë¹ˆ í˜ì´ì§€</button>
                    </div>
                    @if (activeDoc != null) {
                        @for (int i = 1; i <= activeDoc.TotalPages; i++) {
                            int p = i;
                            <div id="thumb-container-@p" class="thumbnail-item @(activeDoc.CurrentPage == p ? "active-page" : "")" @onclick="() => ScrollToPage(p)">
                                <div class="thumb-header"><span class="badge bg-secondary">@p</span></div><canvas id="thumb-@p" class="thumb-canvas"></canvas>
                            </div>
                        }
                    }
                </div>
            }
        </div>
        <div class="splitter" @onmousedown="StartResizeSidebar"><div class="splitter-toggle-btn" @onmousedown:stopPropagation="true" @onclick="ToggleSidebar">â—€</div></div>

        <div id="pdf-container">
            @if (activeDoc != null) {
                @for (int i = 1; i <= activeDoc.TotalPages; i++) {
                    int pageNum = i;
                    <div id="anchor-page-@pageNum" class="page-container" data-page-number="@pageNum" style="margin-bottom: 20px;">
                        <div id="page-wrapper-@pageNum" class="page-wrapper" @onmousedown="@(e => OnPageMouseDown(e, pageNum))" @onmousemove="@(e => OnPageMouseMove(e, pageNum))" style="position: relative;">
                            <canvas id="canvas-@pageNum"></canvas>
                            <div id="text-layer-@pageNum" class="textLayer"></div>
                            
                            @foreach (var item in activeDoc.Annotations.Where(a => a.Page == pageNum && a.Type != "OCR_TEXT")) { 
                                var scaledX = item.X * activeDoc.Scale;
                                var scaledY = item.Y * activeDoc.Scale;
                                var scaledW = item.Width * activeDoc.Scale;
                                var scaledH = item.Height * activeDoc.Scale;
                                var scaledFont = item.FontSize * activeDoc.Scale;

                                if (item.Type=="TEXT"){ <div class="annotation-container @(item==activeDoc.SelectedAnnotation?"selected":"")" style="left:@(scaledX)px;top:@(scaledY)px;position:absolute; z-index:10;" @onmousedown:stopPropagation="true" @onclick:stopPropagation="true" @onmousedown="()=>SelectAnnotation(item)"><div class="drag-handle" @onmousedown="@(e=>StartDragAnnotation(item,e))">âœ¥</div><textarea id="ann-@item.Id" class="input-annotation" style="color:@(item.Color);font-size:@(scaledFont)px;width:200px;" @bind="item.Content" @onmousedown:stopPropagation="true" oninput="autoResize(this)" onfocus="autoResize(this)"></textarea></div> }
                                else if (item.Type.StartsWith("HIGHLIGHT")){ 
                                    var color = item.Type == "HIGHLIGHT_O" ? "rgba(255,165,0,0.4)" : "rgba(255,255,0,0.4)";
                                    <div class="@(item==activeDoc.SelectedAnnotation?"selected":"")" style="position:absolute;left:@(scaledX)px;top:@(scaledY)px;width:@(scaledW)px;height:@(scaledH)px;background-color:@color;cursor:pointer;border:@(item==activeDoc.SelectedAnnotation?"2px solid blue":"none"); z-index:10;" @onmousedown:stopPropagation="true" @onclick:stopPropagation="true" @onmousedown="()=>SelectAnnotation(item)"></div> 
                                }
                                else if (item.Type == "UNDERLINE") {
                                    <div class="@(item==activeDoc.SelectedAnnotation?"selected":"")" style="position:absolute;left:@(scaledX)px;top:@(scaledY)px;width:@(scaledW)px;height:@(scaledH)px;border-bottom:2px solid red;cursor:pointer; z-index:10;" @onmousedown:stopPropagation="true" @onclick:stopPropagation="true" @onmousedown="()=>SelectAnnotation(item)"></div>
                                }
                            }

                            @if ((activeMode == "HIGHLIGHT" || activeMode == "SNAPSHOT") && activeDoc != null) {
                                <div class="drawing-overlay"
                                     @onmousedown="@(e => OnPageMouseDown(e, pageNum))"
                                     @onmousemove="@(e => OnPageMouseMove(e, pageNum))"
                                     @onmouseup="@(e => OnGlobalMouseUp(e))"
                                     style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:999; cursor:crosshair;">
                                </div>
                            }

                            @if ((isDrawingHighlight || isSnapshotMode) && drawingPage == pageNum) { 
                                <div style="position:absolute;left:@(Math.Min(drawStartX, drawCurX))px;top:@(Math.Min(drawStartY, drawCurY))px;width:@(Math.Abs(drawCurX-drawStartX))px;height:@(Math.Abs(drawCurY-drawStartY))px;background-color:@(isSnapshotMode?"rgba(0,0,255,0.2)":"rgba(255,255,0,0.4)");border:1px solid @(isSnapshotMode?"blue":"orange");pointer-events:none; z-index:1000;"></div> 
                            }
                        </div>
                    </div>
                }
                
                @if (showSelectionPopup) {
                    <div class="selection-popup" style="left:@(popupX)px; top:@(popupY)px;" @onmousedown:stopPropagation="true">
                        <div class="popup-btn" @onclick='() => HighlightSelection("HIGHLIGHT_Y")' title="í˜•ê´‘íœ (ë…¸ë‘)">ğŸŸ¡</div>
                        <div class="popup-btn" @onclick='() => HighlightSelection("HIGHLIGHT_O")' title="í˜•ê´‘íœ (ì£¼í™©)">ğŸŸ </div>
                        <div class="popup-btn" @onclick='() => HighlightSelection("UNDERLINE")' title="ë°‘ì¤„"><u>U</u></div>
                        <div class="popup-divider"></div>
                        <div class="popup-btn" @onclick="CopySelection" title="ë³µì‚¬">ğŸ“‹</div>
                    </div>
                }
            } else { <div class="d-flex align-items-center justify-content-center h-100 text-muted"><h3>íŒŒì¼ì„ ì—´ì–´ì£¼ì„¸ìš”.</h3></div> }
        </div>
    </div>
    
    @if (isOcrProcessing) {
        <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; display:flex; justify-content:center; align-items:center; color:white; flex-direction:column;">
            <div class="spinner-border text-light" role="status" style="width: 3rem; height: 3rem;"></div>
            <h3 class="mt-3">OCR ë¶„ì„ ì¤‘...</h3>
            <p>@ocrProgressMessage</p>
            <div class="progress" style="width: 300px; height: 20px;">
                <div class="progress-bar bg-success" style="width: @(ocrProgressPercent)%"></div>
            </div>
        </div>
    }
    
    @if (isContextMenuVisible) {
        <div class="context-menu" style="left:@(contextMenuX)px; top:@(contextMenuY)px;">
            <div class="menu-item" @onclick="ConfirmDeletePage">ğŸ—‘ï¸ í˜ì´ì§€ ì‚­ì œ</div>
            <div class="menu-item" @onclick="() => AddBlankPage(contextMenuTargetPage)">ğŸ“„ ë¹ˆ í˜ì´ì§€ ì¶”ê°€ (ë’¤ì—)</div>
            <div class="menu-item" @onclick="() => PastePageFromClipboard(contextMenuTargetPage)">ğŸ“‹ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸° (ë’¤ì—)</div>
        </div>
    }
    
    @if (showSearchBar) {
        <div class="search-bar animate-fade-in">
            <input id="searchInput" type="text" placeholder="ê²€ìƒ‰ì–´ ì…ë ¥..." @bind="searchQuery" @onkeyup="HandleSearchKeyUp" />
            <button class="icon-only-btn" @onclick="SearchPrev">â–²</button><button class="icon-only-btn" @onclick="SearchNext">â–¼</button>
            <span class="search-count">@(searchResultCount > 0 ? $"{currentSearchIndex + 1} / {searchResultCount}" : "0 / 0")</span>
            <button class="btn-close ms-2" @onclick="CloseSearchBar"></button>
        </div>
    }
</div>

@code {
    private List<PdfDocumentModel> docs = new List<PdfDocumentModel>();
    private PdfDocumentModel? activeDoc = null;
    private string activeMode = "INFO";
    private string activeTab = "PROP";
    private string currentInputColor = "#000000";
    private int currentInputFontSize = 16;
    private int sidebarWidth = 250; private bool isSidebarOpen = true; private bool isSidebarResizing = false;
    private AnnotationData? draggingAnnotation = null; private double lastMouseX, lastMouseY;
    private bool isDrawingHighlight = false; private bool isSnapshotMode = false;
    private int drawingPage = -1; private double drawStartX, drawStartY, drawCurX, drawCurY;
    private bool isContextMenuVisible = false; private double contextMenuX, contextMenuY;
    private int contextMenuTargetPage = -1;
    private bool showSearchBar = false; private string searchQuery = ""; private int searchResultCount = 0;
    private int currentSearchIndex = 0;
    
    private bool showMoreMenu = false;
    private double thumbnailScale = 0.2;
    private Timer? zoomTimer;
    private bool isRendering = false;
    private DotNetObjectReference<Home>? dotNetRef;

    private bool showSelectionPopup = false;
    private double popupX, popupY;
    private int selectedPageNum;
    private double selX, selY, selW, selH;
    private string selectedText = "";

    private bool isOcrProcessing = false;
    private string ocrProgressMessage = "";
    private int ocrProgressPercent = 0;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) { 
            try { 
                dotNetRef = DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("initPdfViewer", dotNetRef); 
                zoomTimer = new Timer(100); zoomTimer.AutoReset = false;
                zoomTimer.Elapsed += async (s, e) => { await InvokeAsync(async () => { await RenderAllPages(); isRendering = false; StateHasChanged(); }); };
            } catch {} 
        }
    }

    private void ToggleMoreMenu() { showMoreMenu = !showMoreMenu; }
    private void CloseMenus() { showMoreMenu = false; showSelectionPopup = false; CloseContextMenu(); }

    [JSInvokable] 
    public void OnTextSelected(double clientX, double clientY, double pdfX, double pdfY, double w, double h, int pageNum, string text) {
        if (activeDoc == null) return;
        if (activeMode != "INFO" && activeMode != "TEXT") return; 

        popupX = clientX; 
        popupY = clientY - 50;
        if (popupY < 10) popupY = clientY + 20;

        selX = pdfX / activeDoc.Scale; 
        selY = pdfY / activeDoc.Scale; 
        selW = w / activeDoc.Scale; 
        selH = h / activeDoc.Scale;
        
        selectedPageNum = pageNum; selectedText = text;
        showSelectionPopup = true; 
        StateHasChanged();
    }
    
    [JSInvokable] public void OnTextSelectionCleared() { 
        if (showSelectionPopup) { showSelectionPopup = false; StateHasChanged(); }
    }
    
    private async Task CopySelection() { 
        await System.Windows.Application.Current.Dispatcher.InvokeAsync(() => {
            try { Clipboard.SetText(selectedText); } catch { }
        });
        showSelectionPopup = false; 
        await JS.InvokeVoidAsync("alert", "í…ìŠ¤íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.");
    }
    
    private void HighlightSelection(string type) {
        if(activeDoc != null) {
            SaveState();
            activeDoc.Annotations.Add(new AnnotationData { Type = type, X = selX, Y = selY, Width = selW, Height = selH, Page = selectedPageNum });
            showSelectionPopup = false;
        }
    }

    private async Task GenerateSearchablePdf() {
        if (activeDoc == null) return;
        isOcrProcessing = true; ocrProgressPercent = 0; StateHasChanged();

        await System.Windows.Application.Current.Dispatcher.InvokeAsync(async () => {
            try {
                activeDoc.Annotations.RemoveAll(a => a.Type == "OCR_TEXT");
                int total = activeDoc.TotalPages; int totalWords = 0; SaveState();

                for (int i = 1; i <= total; i++) {
                    ocrProgressMessage = $"{i} / {total} í˜ì´ì§€ ì²˜ë¦¬ ì¤‘..."; ocrProgressPercent = (int)((double)i / total * 100); StateHasChanged();
                    await Task.Delay(10); 
                    string base64Image = await JS.InvokeAsync<string>("getPageImageBase64", i);
                    if(!string.IsNullOrEmpty(base64Image)) {
                        byte[] imgBytes = Convert.FromBase64String(base64Image);
                        var results = await OcrService.ExtractTextWithCoords(imgBytes);
                        totalWords += results.Count;
                        foreach(var res in results) {
                            activeDoc.Annotations.Add(new AnnotationData { Type = "OCR_TEXT", Content = res.Text, X = res.X / 3.0, Y = res.Y / 3.0, Width = res.Width / 3.0, Height = res.Height / 3.0, Page = i });
                        }
                    }
                }

                if (totalWords > 0) {
                    ocrProgressMessage = "PDF ì¬êµ¬ì„± ì¤‘..."; StateHasChanged(); await Task.Delay(50);
                    byte[] newPdfData = PdfService.SavePdfWithAnnotations(activeDoc.Data, activeDoc.Annotations, activeDoc.Scale);
                    activeDoc.Data = newPdfData; activeDoc.Annotations.RemoveAll(a => a.Type == "OCR_TEXT");
                    activeDoc.TotalPages = await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data);
                    await RenderAllPages();
                    await JS.InvokeVoidAsync("alert", $"OCR ì™„ë£Œ! {totalWords}ê°œì˜ ë‹¨ì–´ê°€ ì¸ì‹ë˜ì—ˆìŠµë‹ˆë‹¤.");
                } else { await JS.InvokeVoidAsync("alert", "ì¸ì‹ëœ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤."); }

            } catch (Exception ex) { await JS.InvokeVoidAsync("alert", "OCR ì˜¤ë¥˜: " + ex.Message);
            } finally { isOcrProcessing = false; StateHasChanged(); }
        });
    }

    private async Task OpenFileWithDialog() {
        var dlg = new OpenFileDialog { Filter = "PDF documents (.pdf)|*.pdf" };
        if (dlg.ShowDialog() == true) {
            try {
                var existing = docs.FirstOrDefault(d => d.FilePath == dlg.FileName);
                if (existing != null) { await SwitchTab(existing); return; }
                var newDoc = new PdfDocumentModel { FilePath = dlg.FileName, FileName = System.IO.Path.GetFileName(dlg.FileName), Data = File.ReadAllBytes(dlg.FileName), Scale = 1.0 };
                var loadedAnns = PdfService.ExtractAnnotationsFromMetadata(newDoc.Data);
                if (loadedAnns != null && loadedAnns.Count > 0) newDoc.Annotations = loadedAnns;
                int lastPage = HistoryService.GetLastPage(newDoc.FilePath);
                docs.Add(newDoc); activeDoc = newDoc;
                activeDoc.TotalPages = await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data);
                StateHasChanged(); await Task.Delay(100); await RenderAllPages(); await JS.InvokeVoidAsync("registerZoomEvent", "pdf-container"); await JS.InvokeVoidAsync("setupPageObserver");
                if (lastPage > 1 && lastPage <= activeDoc.TotalPages) await ScrollToPage(lastPage);
            } catch (Exception ex) { await JS.InvokeVoidAsync("alert", "ì—´ê¸° ì‹¤íŒ¨: " + ex.Message); }
        }
    }
    
    private async Task SwitchTab(PdfDocumentModel doc) { if (activeDoc == doc) return;
        activeDoc = doc; await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data); StateHasChanged(); await Task.Delay(50); await RenderAllPages(); await RenderThumbnails(); await JS.InvokeVoidAsync("setupPageObserver"); await ScrollToPage(activeDoc.CurrentPage);
    }
    private void CloseTab(PdfDocumentModel doc) { docs.Remove(doc); if (activeDoc == doc) { activeDoc = docs.FirstOrDefault();
        if (activeDoc != null) SwitchTab(activeDoc); else StateHasChanged(); } }
    
    private async Task OnGlobalMouseUp(MouseEventArgs e) { 
        if (isSidebarResizing) isSidebarResizing = false;
        if (draggingAnnotation != null) { draggingAnnotation = null; SaveState(); } 
        
        double x = Math.Min(drawStartX, drawCurX); double y = Math.Min(drawStartY, drawCurY);
        double w = Math.Abs(drawCurX - drawStartX); double h = Math.Abs(drawCurY - drawStartY);
        
        if (isDrawingHighlight && activeDoc != null) { 
            if (w > 5 && h > 5) { 
                SaveState();
                activeDoc.Annotations.Add(new AnnotationData { Type="HIGHLIGHT", X=x/activeDoc.Scale, Y=y/activeDoc.Scale, Width=w/activeDoc.Scale, Height=h/activeDoc.Scale, Page=drawingPage }); 
            } 
            isDrawingHighlight = false; drawingPage = -1; 
            // [ìˆ˜ì •] í† ê¸€ ìœ ì§€: activeMode="INFO"ë¡œ ê°•ì œ ì „í™˜í•˜ì§€ ì•ŠìŒ
            StateHasChanged();
        } else if (isSnapshotMode && activeDoc != null) { 
            if (w > 5 && h > 5) { 
                await JS.InvokeVoidAsync("copySnapshot", x, y, w, h, drawingPage);
                await System.Windows.Application.Current.Dispatcher.InvokeAsync(async () => { if (Clipboard.ContainsImage()) { var bitmap = Clipboard.GetImage(); byte[] imgBytes; var pngEncoder = new PngBitmapEncoder(); pngEncoder.Frames.Add(BitmapFrame.Create(bitmap)); using (var ms = new MemoryStream()) { pngEncoder.Save(ms); imgBytes = ms.ToArray(); } string extractedText = await OcrService.ExtractTextFromImage(imgBytes); if (!string.IsNullOrWhiteSpace(extractedText)) { Clipboard.SetText(extractedText); await JS.InvokeVoidAsync("alert", $"[ìº¡ì²˜ ì™„ë£Œ]\ní…ìŠ¤íŠ¸ ë³µì‚¬ë¨:\n\n{extractedText}"); } else { await JS.InvokeVoidAsync("alert", "OCR: ê¸€ì ì—†ìŒ"); } } });
            } 
            isSnapshotMode = false; drawingPage = -1;
            // ìº¡ì²˜ëŠ” 1íšŒì„±ì´ë¯€ë¡œ í’€ë¦¬ëŠ”ê²Œ ì¢‹ì§€ë§Œ, ì›í•˜ì‹œë©´ ì—¬ê¸°ë„ ìœ ì§€ ê°€ëŠ¥ (í˜„ì¬ëŠ” í’€ë¦¼)
            await InvokeAsync(() => { SetMode("INFO"); StateHasChanged(); });
        } 
    }
    
    [JSInvokable] public async Task OnPageVisible(int pageNum) { if (activeDoc != null && activeDoc.CurrentPage != pageNum) { activeDoc.CurrentPage = pageNum;
        HistoryService.SaveLastPage(activeDoc.FilePath, pageNum); StateHasChanged(); if (activeTab == "PAGES") await JS.InvokeVoidAsync("scrollThumbnailIntoView", pageNum);
    } }
    
    private void SaveState() { if (activeDoc == null) return;
        var json = JsonSerializer.Serialize(activeDoc.Annotations); activeDoc.UndoStack.Push(json); if (activeDoc.UndoStack.Count > 20) { var temp = activeDoc.UndoStack.ToArray(); activeDoc.UndoStack.Clear(); for(int i=19; i>=0; i--) activeDoc.UndoStack.Push(temp[i]);
    } }
    [JSInvokable] public void OnUndo() => Undo();
    private void Undo() { if (activeDoc != null && activeDoc.UndoStack.Count > 0) { var json = activeDoc.UndoStack.Pop();
        activeDoc.Annotations = JsonSerializer.Deserialize<List<AnnotationData>>(json) ?? new List<AnnotationData>(); activeDoc.SelectedAnnotation = null; StateHasChanged();
    } }
    
    [JSInvokable] public void OnZoomIn() => RequestZoom(0.1);
    [JSInvokable] public void OnZoomOut() => RequestZoom(-0.1);
    private void RequestZoom(double delta) { if (activeDoc == null) return;
        double newScale = activeDoc.Scale + delta; if (newScale < 0.2) newScale = 0.2; if (newScale > 5.0) newScale = 5.0;
        activeDoc.Scale = newScale; StateHasChanged(); zoomTimer?.Stop(); zoomTimer?.Start(); }
    private async Task ZoomIn() { if (isRendering || activeDoc == null) return;
        if (activeDoc.Scale >= 5.0) return; isRendering = true; activeDoc.Scale += 0.2; await RenderAllPages(); isRendering = false;
    }
    private async Task ZoomOut() { if (isRendering || activeDoc == null) return;
        if (activeDoc.Scale > 0.4) { isRendering = true; activeDoc.Scale -= 0.2; await RenderAllPages(); isRendering = false;
    } }
    private async Task ResetZoom() { if(activeDoc!=null) { activeDoc.Scale = 1.0; await RenderAllPages(); } }
    private async Task FitToWidth() { if (activeDoc == null) return;
        double scale = await JS.InvokeAsync<double>("getFitScale", "width"); activeDoc.Scale = Math.Round(scale, 2) - 0.02; await RenderAllPages();
    }
    private async Task FitToPage() { if (activeDoc == null) return; double scale = await JS.InvokeAsync<double>("getFitScale", "height");
        activeDoc.Scale = Math.Round(scale, 2); await RenderAllPages(); }
    
    private async Task RenderAllPages() { if (activeDoc == null) return;
        for (int i = 1; i <= activeDoc.TotalPages; i++) await JS.InvokeVoidAsync("renderPageById", i, activeDoc.Scale, $"canvas-{i}", $"page-wrapper-{i}", $"text-layer-{i}");
    }
    private async Task RenderThumbnails() { if (activeTab != "PAGES" || activeDoc == null) return;
        for (int i = 1; i <= activeDoc.TotalPages; i++) await JS.InvokeVoidAsync("renderThumbnail", i, $"thumb-{i}", thumbnailScale);
    }
    private async Task ScrollToPage(int pageNum) { await JS.InvokeVoidAsync("eval", $"document.getElementById('anchor-page-{pageNum}')?.scrollIntoView({{behavior:'auto', block:'start'}})"); }
    
    private void OnColorChanged(ChangeEventArgs e) { currentInputColor = e.Value?.ToString() ?? "#000000";
        if(activeDoc?.SelectedAnnotation != null) activeDoc.SelectedAnnotation.Color = currentInputColor; }
    private void OnSizeChanged(ChangeEventArgs e) { if(int.TryParse(e.Value?.ToString(), out int s)) { currentInputFontSize = s;
        if(activeDoc?.SelectedAnnotation != null) activeDoc.SelectedAnnotation.FontSize = currentInputFontSize; } }
    private void ApplyStyles() { if (activeDoc?.SelectedAnnotation != null) { SaveState();
        activeDoc.SelectedAnnotation.Color = currentInputColor; activeDoc.SelectedAnnotation.FontSize = currentInputFontSize; } }
    
    private void SavePdf() { if (activeDoc == null) return;
        try { var finalBytes = PdfService.SavePdfWithAnnotations(activeDoc.Data, activeDoc.Annotations, activeDoc.Scale); File.WriteAllBytes(activeDoc.FilePath, finalBytes); activeDoc.Data = finalBytes; JS.InvokeVoidAsync("alert", "ì €ì¥ ì™„ë£Œ!");
        } catch (Exception ex) { JS.InvokeVoidAsync("alert", "ì €ì¥ ì‹¤íŒ¨: " + ex.Message); } }

    // [ìˆ˜ì •] ì¶©ëŒ ë°©ì§€: async Taskë¡œ ë³€ê²½í•˜ê³ , ì €ì¥ ì „ ëª¨ë“œ ì´ˆê¸°í™” ë° ë”œë ˆì´ ì¶”ê°€
    private async Task SavePdfAs() { 
        if (activeDoc == null) return;
        
        // ì•ˆì „ì¥ì¹˜: ì˜¤ë²„ë ˆì´ ì œê±° ë° UI ìŠ¤ë ˆë“œ ì•ˆì •í™”
        SetMode("INFO"); 
        StateHasChanged(); 
        await Task.Delay(100); 

        var dlg = new SaveFileDialog { FileName = activeDoc.FileName, DefaultExt = ".pdf", Filter = "PDF documents (.pdf)|*.pdf" };
        if (dlg.ShowDialog() == true) { 
            try { 
                var finalBytes = PdfService.SavePdfWithAnnotations(activeDoc.Data, activeDoc.Annotations, activeDoc.Scale); 
                File.WriteAllBytes(dlg.FileName, finalBytes); 
                activeDoc.FilePath = dlg.FileName;
                activeDoc.FileName = System.IO.Path.GetFileName(dlg.FileName); 
                activeDoc.Data = finalBytes; 
                StateHasChanged(); 
            } catch (Exception ex) {
                // í˜¹ì‹œ ëª¨ë¥¼ ì˜¤ë¥˜ ëŒ€ë¹„
                await JS.InvokeVoidAsync("alert", "ì €ì¥ ì‹¤íŒ¨: " + ex.Message);
            }
        } 
    }
    
    [JSInvokable] public void OnDeleteSelected() => DeleteSelected();
    private void DeleteSelected() { if (activeDoc?.SelectedAnnotation != null) { SaveState(); activeDoc.Annotations.Remove(activeDoc.SelectedAnnotation); activeDoc.SelectedAnnotation = null; } }
    private void SelectAnnotation(AnnotationData item) { if(activeDoc!=null) activeDoc.SelectedAnnotation = item; }
    private void StartDragAnnotation(AnnotationData item, MouseEventArgs e) { if(activeDoc!=null) { draggingAnnotation = item; activeDoc.SelectedAnnotation = item; lastMouseX = e.ClientX; lastMouseY = e.ClientY; } }
    
    private async Task OnPageMouseDown(MouseEventArgs e, int pageNum) { if (activeDoc == null) return;
        if (activeMode == "TEXT") { SaveState(); var newAnn = new AnnotationData { Id=Guid.NewGuid().ToString(), Type="TEXT", Content="", X=e.OffsetX/activeDoc.Scale, Y=e.OffsetY/activeDoc.Scale, Page=pageNum, FontSize=currentInputFontSize, Color=currentInputColor };
            activeDoc.Annotations.Add(newAnn); SelectAnnotation(newAnn); activeMode = "INFO"; StateHasChanged(); await JS.InvokeVoidAsync("focusElement", "ann-" + newAnn.Id);
        } else if (activeMode == "HIGHLIGHT" || activeMode == "SNAPSHOT") { 
            if(activeMode=="HIGHLIGHT") isDrawingHighlight = true; else isSnapshotMode = true;
            drawingPage = pageNum; drawStartX = e.OffsetX; drawStartY = e.OffsetY; drawCurX = e.OffsetX; drawCurY = e.OffsetY;
        } }
    private void OnPageMouseMove(MouseEventArgs e, int pageNum) { if ((isDrawingHighlight || isSnapshotMode) && drawingPage == pageNum) { drawCurX = e.OffsetX; drawCurY = e.OffsetY; } }
    private void OnGlobalMouseMove(MouseEventArgs e) { if (isSidebarResizing) { if (e.ClientX > 100 && e.ClientX < 500) sidebarWidth = (int)e.ClientX; return; } if (draggingAnnotation != null) { draggingAnnotation.X += (e.ClientX - lastMouseX)/activeDoc.Scale; draggingAnnotation.Y += (e.ClientY - lastMouseY)/activeDoc.Scale; lastMouseX = e.ClientX; lastMouseY = e.ClientY; } }
    
    private async Task AddBlankPage(int targetPage = -1) { if (activeDoc == null) return;
        SaveState(); int idx = targetPage == -1 ? -1 : targetPage; activeDoc.Data = PdfService.AddBlankPage(activeDoc.Data, idx); activeDoc.TotalPages = await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data); await RenderAllPages(); await RenderThumbnails(); }
    
    private async Task PastePageFromClipboard(int targetPage = -1) { if (activeDoc == null) return; CloseContextMenu(); 
        byte[]? imgBytes = null; await System.Windows.Application.Current.Dispatcher.InvokeAsync(() => { try { if (Clipboard.ContainsImage()) { var bitmap = Clipboard.GetImage(); var pngEncoder = new PngBitmapEncoder(); pngEncoder.Frames.Add(BitmapFrame.Create(bitmap)); using (var ms = new MemoryStream()) { pngEncoder.Save(ms); imgBytes = ms.ToArray(); } } } catch { } });
        if (imgBytes != null) { SaveState(); int idx = targetPage == -1 ? -1 : targetPage; activeDoc.Data = PdfService.AddImagePage(activeDoc.Data, imgBytes, idx); activeDoc.TotalPages = await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data); await RenderAllPages(); await RenderThumbnails(); } }
    
    private async Task ConfirmDeletePage() { if (activeDoc == null) return; CloseContextMenu(); bool ok = await JS.InvokeAsync<bool>("confirm", $"{contextMenuTargetPage}í˜ì´ì§€ ì‚­ì œ?"); if (ok) await DeletePage(contextMenuTargetPage); }
    private async Task DeletePage(int pageNum) { if (activeDoc == null) return; SaveState();
        activeDoc.Data = PdfService.DeletePage(activeDoc.Data, pageNum - 1); activeDoc.Annotations.RemoveAll(a => a.Page == pageNum); foreach (var ann in activeDoc.Annotations.Where(a => a.Page > pageNum)) ann.Page--; activeDoc.TotalPages = await JS.InvokeAsync<int>("loadPdfDocument", activeDoc.Data); await RenderAllPages(); await RenderThumbnails(); }
    
    [JSInvokable] public async Task OnThumbnailZoomIn() { thumbnailScale += 0.05; await RenderThumbnails(); }
    [JSInvokable] public async Task OnThumbnailZoomOut() { if(thumbnailScale > 0.1) { thumbnailScale -= 0.05; await RenderThumbnails(); } }
    
    private async Task SwitchToPagesTab() { activeTab = "PAGES"; StateHasChanged(); await Task.Delay(50); await RenderThumbnails(); await JS.InvokeVoidAsync("registerSidebarZoomEvent", "sidebar-thumbnails"); }
    private void StartResizeSidebar(MouseEventArgs e) => isSidebarResizing = true;
    private void ToggleSidebar() => isSidebarOpen = !isSidebarOpen;
    
    // [ìˆ˜ì •] ëª¨ë“œ í† ê¸€: ì´ë¯¸ ì„ íƒëœ ëª¨ë“œë¥¼ ë‹¤ì‹œ ëˆ„ë¥´ë©´ OFF
    private void SetMode(string mode) {
        if (activeMode == mode) activeMode = "INFO";
        else activeMode = mode;
    }
    private void CloseContextMenu() => isContextMenuVisible = false;
    private void ShowContextMenu(MouseEventArgs e, int pageNum) { isContextMenuVisible = true; contextMenuX = e.ClientX; contextMenuY = e.ClientY; contextMenuTargetPage = pageNum; }
    
    [JSInvokable] public async Task OnCtrlF() => await ToggleSearchBar();
    private async Task ToggleSearchBar() { showSearchBar = !showSearchBar; StateHasChanged(); if (showSearchBar) { await Task.Delay(50); await JS.InvokeVoidAsync("focusElement", "searchInput"); } else { await JS.InvokeVoidAsync("clearSearchHighlights"); searchQuery = ""; searchResultCount = 0; } }
    private void CloseSearchBar() { showSearchBar = false; JS.InvokeVoidAsync("clearSearchHighlights"); }
    private async Task HandleSearchKeyUp(KeyboardEventArgs e) { if (e.Key == "Enter") { if (e.ShiftKey) await SearchPrev(); else await SearchNext(); } else { await ExecuteSearch(); } }
    private async Task ExecuteSearch() { if (string.IsNullOrWhiteSpace(searchQuery)) { await JS.InvokeVoidAsync("clearSearchHighlights"); searchResultCount = 0; return; } searchResultCount = await JS.InvokeAsync<int>("performSearch", searchQuery); currentSearchIndex = 0; if (searchResultCount > 0) await JS.InvokeVoidAsync("highlightNextMatch", 0); }
    private async Task SearchNext() { if (searchResultCount > 0) { currentSearchIndex++; if (currentSearchIndex >= searchResultCount) currentSearchIndex = 0; await JS.InvokeVoidAsync("highlightNextMatch", currentSearchIndex); } }
    private async Task SearchPrev() { if (searchResultCount > 0) { currentSearchIndex--; if (currentSearchIndex < 0) currentSearchIndex = searchResultCount - 1; await JS.InvokeVoidAsync("highlightNextMatch", currentSearchIndex); } }
    
    public void Dispose() { dotNetRef?.Dispose(); zoomTimer?.Dispose(); }
}